# 企业级项目目录布局设计方案

## 1. 研究结论（行业最佳实践）
- 前后端分离：前端与后端独立工程、独立构建与部署，通过 API 契约联动 [1][2]
- 前端目录：按“按功能分组（group-by-feature）+ 共享层”组织，抽象 API/状态/UI/样式/工具的边界 [2][4][5]
- 后端目录：按分层/领域模型（DDD/六边形/分层架构）组织，清晰区分 `接口层→应用层→领域层→基础设施层`，模块化拆分可重用能力 [4]

> 参考：Hexacta 项目结构（前后端分离）[1]；前端架构与分层（ELITEX/Elegant Frontend Architecture）[2][4]；企业级按功能分组与Monorepo实践[5]

## 2. 现有项目特征分析
- 项目类型：Web应用，前后端分离
- 技术栈：
  - 前端：Vue3 + Vite + Element Plus + Pinia + Vue Router + Vitest + Playwright
  - 后端：Spring Boot 2.7 + MyBatis-Plus + Redis + RabbitMQ + WebSocket + Nacos + MapStruct/EasyExcel等
- 目录结构（简）：
  - `hospital-frontend/`：`src/api、components、views（患者/医生/管理员）、stores、router、styles、utils、tests...`
  - `hospital-appointment-system/`：`src/main/java/com.hospital/*（controller、service、mapper、entity...）、resources（mapper xml、yml）`
- 业务模块：预约、排班、用户/角色、体质评估、药膳、文章社区、医患对话、通知、统计、系统设置等

## 3. 优化目录布局方案（企业级标准）

### 3.1 顶层目录
```
hospital/
├─ hospital-frontend/              # 前端工程（Vue3）
├─ hospital-appointment-system/    # 后端工程（Spring Boot，多模块可选）
├─ docs/                           # 设计与运维文档
├─ .editorconfig
├─ .gitignore
└─ README.md
```

### 3.2 前端（Vue3）目录（按功能分组）
```
hospital-frontend/
├─ src/
│  ├─ app/                       # 应用入口与全局配置（App.vue、main.ts、providers）
│  ├─ features/                  # 业务功能分组（按领域）
│  │  ├─ appointment/            # 预约
│  │  │  ├─ pages/               # 页面（预约、我的预约）
│  │  │  ├─ components/          # 本功能内组件
│  │  │  ├─ api.ts               # 预约API封装
│  │  │  ├─ store.ts             # 本功能状态（Pinia）
│  │  │  └─ index.ts             # 聚合导出
│  │  ├─ schedule/                # 排班
│  │  ├─ tcm-eval/                # 体质评估
│  │  ├─ recipe/                  # 药膳推荐
│  │  ├─ dialogue/                # 医患对话
│  │  ├─ article/                 # 社区文章
│  │  └─ system/                  # 系统设置/统计
│  ├─ shared/                    # 共享层（跨功能可复用）
│  │  ├─ components/             # 基础或复用组件（Button、Modal、Table等）
│  │  ├─ ui/                     # 设计系统（样式变量、主题、Mixin）
│  │  ├─ hooks/                  # 组合式函数（useAuth、useFetch等）
│  │  ├─ lib/                    # 工具库（http实例、缓存、日志）
│  │  ├─ types/                  # TS类型与接口契约
│  │  └─ config/                 # 运行时配置（runtimeConfig、env）
│  ├─ router/                    # 路由（按功能懒加载）
│  ├─ store/                     # 全局状态（用户/通知）
│  ├─ assets/                    # 静态资源（图片、图标）
│  ├─ styles/                    # 全局样式（reset、主题）
│  └─ tests/                     # 单元/e2e测试
├─ public/
├─ vite.config.ts
├─ .env.development / .env.production
└─ package.json
```
要点：
- `features/*` 聚合页面、组件、API、store，提升内聚与可维护性
- `shared/*` 承载跨域复用能力，避免耦合到具体功能
- 路由与状态按功能模块化，统一 API 层（axios 实例与错误处理）

### 3.3 后端（Spring Boot）目录（DDD/分层推荐）
可保留单模块，也建议向“多模块”演进：
```
hospital-appointment-system/
├─ pom.xml
├─ hospital-app/                   # 应用服务（可执行模块，REST、配置）
│  └─ src/main/java/com.hospital.app/
│     ├─ api/                     # 接口层（controller、DTO、VO、assembler）
│     ├─ config/                  # 配置（安全、序列化、跨域、mq、redis等）
│     ├─ security/                # 安全（鉴权、JWT拦截器）
│     ├─ ws/                      # WebSocket入口
│     └─ HospitalApplication.java
├─ hospital-application/          # 应用层（用例编排、服务协调）
│  └─ src/main/java/com.hospital.application/
│     └─ service/                 # 用例服务（无技术细节）
├─ hospital-domain/               # 领域层（实体、值对象、领域服务、聚合）
│  └─ src/main/java/com.hospital.domain/
│     ├─ model/                   # 实体/VO（如 Appointment、Doctor、Recipe）
│     ├─ repository/              # 仓储接口（端口）
│     └─ domain-service/          # 领域服务
├─ hospital-infrastructure/       # 基础设施层（技术实现）
│  └─ src/main/java/com.hospital.infrastructure/
│     ├─ repository/impl          # 仓储实现（MyBatis-Plus）
│     ├─ mapper/                  # Mapper接口与XML
│     ├─ mq/redis/oss/...         # 外部系统适配
│     └─ config/                  # 技术相关配置
├─ hospital-common/               # 公共模块（工具、异常、通用返回体、常量）
│  └─ src/main/java/com.hospital.common/
└─ resources/
   ├─ application-*.yml
   └─ mapper/*.xml
```
要点：
- `api→application→domain→infrastructure` 严格依赖方向，领域与技术解耦
- 领域仓储用接口表示（端口），基础设施实现细节（适配器）落在 infra
- 以业务模块为聚合单元（预约/排班/评估/药膳/文章/对话/统计/系统），逐步拆分到独立包/模块

## 4. 实施建议与迁移步骤
### 4.1 目录结构文档与职责说明
- 前端
  - `features/*`：该领域的页面、组件、API与store均在此目录，提升内聚
  - `shared/*`：通用UI、hooks、lib、types与config，跨模块复用
  - `router`：仅承载路由声明，逻辑回归各功能模块
  - `tests`：单元（Vitest）与端到端（Playwright）规范组织
- 后端
  - `api`：REST接口、DTO/响应体、装配器；仅耦合 `application`
  - `application`：用例服务编排（事务/流程），不引入技术细节
  - `domain`：实体/值对象/领域服务/仓储接口；不依赖框架
  - `infrastructure`：MyBatis-Plus、Redis、MQ等实现与适配
  - `common`：异常、通用返回体、常量、工具类、日志规范

### 4.2 迁移步骤（建议渐进）
1) 前端
   - 在 `src/features` 下创建：`appointment、schedule、tcm-eval、recipe、dialogue、article、system` 七个目录
   - 将 `views/patient/*` 按领域迁入对应 `features/*/pages`
   - 将 `api/*.js` 分拆为 `features/*/api.ts`，共享 axios 实例迁入 `shared/lib/http.ts`
   - 将跨领域组件搬到 `shared/components`；全局 hooks 搬到 `shared/hooks`
   - 路由改造为按功能懒加载；Pinia store按功能模块拆分
2) 后端
   - 新建多模块骨架（`hospital-app、hospital-application、hospital-domain、hospital-infrastructure、hospital-common`）
   - 将 `controller` 迁至 `app/api`；`service`（业务编排）迁至 `application/service`
   - 将 `entity` 迁至 `domain/model`；将 `mapper` 接口转为 `domain/repository`（接口），其实现迁入 `infrastructure/repository/impl`
   - 将技术配置（Redis、MQ、OSS）迁入 `infrastructure/config`；通用返回体/异常迁入 `common`
   - 逐模块（预约/排班/评估/药膳/文章/对话/统计/系统）完成包内迁移与依赖梳理

### 4.3 配置文件位置与标准化
- 前端：`.env.development/.env.production`；`vite.config.ts`；`src/shared/config/runtimeConfig.ts`
- 后端：`hospital-app/src/main/resources/application-*.yml`；模块内 `resources` 仅放置当前模块资源（mapper/xml等）
- 统一 `.editorconfig`、ESLint/Prettier、Checkstyle/Spotless、Commitlint/Husky、CI（构建/测试/质量门禁）

## 5. 新旧结构对比与实施路线图
### 5.1 结构对比（示例）
| 维度 | 旧结构 | 新结构 |
|---|---|---|
| 前端组织 | 视图+通用 API 散落 | 按功能分组（features）+共享层（shared），路由/状态按功能模块化 |
| 后端组织 | controller/service/mapper/entity 混杂 | 分层+领域化，仓储接口与实现分离，技术细节落在 infra |
| 模块边界 | 领域耦合 | 预约/排班/评估/药膳/文章/对话/统计/系统 边界清晰 |
| 可维护性 | 变更扩散 | 变更在单模块内收敛，边界稳定，依赖向内收缩 |

### 5.2 实施路线图
1) 文档与规范落地：目录方案/编码规范/提交规范/CI质量门禁
2) 前端功能化迁移：`features/*` 骨架→预约模块→其他模块（逐步）
3) 后端分层与领域化：建立多模块→预约模块迁移→其余模块迭代迁移
4) 契约与测试：前后端 API 契约化（OpenAPI/接口文档）+ 单测/集成/E2E
5) 运维与发布：环境配置标准化、分环境部署、回滚与监控

### 5.3 注意事项
- 保持渐进式迁移，先搭骨架，再按模块迁移，避免一次性大改
- 保持接口契约与数据模型稳定；对外兼容，内部重构
- 领域层禁止引入框架类型；基础设施适配框架，向上通过接口输出能力
- 前端共享层避免业务耦合；功能层拥有完整闭环能力

---
**参考**
- [1] Hexacta 项目结构（前后端分离）: https://github.com/hexacta/project-structure-sample
- [2] ELITEX 前端架构深度分析（2025）: https://elitex.systems/blog/front-end-architecture-in-depth-analysis
- [4] Elegant Frontend Architecture（DDD分层到前端）: https://michalzalecki.com/elegant-frontend-architecture/
- [5] Front-End Directory Structures（企业级与Monorepo实践）: https://leapcell.io/blog/tailoring-front-end-directory-structures-to-project-size-and-team-practices

